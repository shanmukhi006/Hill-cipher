# -*- coding: utf-8 -*-
"""Hillcipher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y9wBe7oNVYWrWUn5JF189R7V2XllUBTL
"""



import numpy as np

def mod_inverse(a, m):
    for i in range(1, m):
        if (a * i) % m == 1:
            return i
    return None

def encrypt(text, key):
    text = text.upper().replace(" ", "")
    while len(text) % 2 != 0:
        text += 'X'  # Padding if text length is not even

    key_matrix = np.array(key)
    if key_matrix.shape != (2, 2):
        raise ValueError("Key matrix must be 2x2")

    text_vector = [[ord(text[i]) - 65, ord(text[i + 1]) - 65] for i in range(0, len(text), 2)]

    encrypted_text = ""
    for pair in text_vector:
        result = np.dot(key_matrix, pair) % 26
        encrypted_text += chr(result[0] + 65) + chr(result[1] + 65)

    return encrypted_text

def decrypt(text, key):
    key_matrix = np.array(key)
    det = int(np.linalg.det(key_matrix))
    det_inv = mod_inverse(det % 26, 26)

    if det_inv is None:
        raise ValueError("Key matrix is not invertible under mod 26")

    adjugate_matrix = np.array([[key_matrix[1, 1], -key_matrix[0, 1]],
                                [-key_matrix[1, 0], key_matrix[0, 0]]])

    inverse_key_matrix = (det_inv * adjugate_matrix) % 26
    inverse_key_matrix = inverse_key_matrix.astype(int)

    text_vector = [[ord(text[i]) - 65, ord(text[i + 1]) - 65] for i in range(0, len(text), 2)]

    decrypted_text = ""
    for pair in text_vector:
        result = np.dot(inverse_key_matrix, pair) % 26
        decrypted_text += chr(result[0] + 65) + chr(result[1] + 65)

    return decrypted_text

# User input
key = [[3, 3], [2, 5]]  # Key matrix should be invertible in mod 26
plaintext = input("Enter plaintext: ")
ciphertext = encrypt(plaintext, key)
print("Encrypted:", ciphertext)
decrypted = decrypt(ciphertext, key)
print("Decrypted:", decrypted)